kutugu

high

# withdrawnReserves create an arbitrage opportunity to steal staking users' fund

## Summary

`_getExchangeRate` calculation is affected by `withdrawnReserves` action, resulting in a instantaneous sandwich arbitrage opportunity.

## Vulnerability Detail

```solidity
    // @notice exchangeRate = (cash + totalBorrows -reserves) / dTokenSupply
    // @notice Make sure accrueInterests or accrueInterest(token) is called before
    function _getExchangeRate(address token) internal view returns (uint256) {
        AssetInfo storage info = assetInfo[token];
        uint256 cash = getCash(token);
        uint256 dTokenSupply = IERC20(info.dToken).totalSupply();
        if (dTokenSupply == 0) { return 1e18; }
        return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);
    }

    function withdrawReserves(address token, uint256 amount) external nonReentrant allowedToken(token) onlyOwner {
        accrueInterest(token);
        AssetInfo storage info = assetInfo[token];
        uint256 totalReserves = info.totalReserves;
        uint256 withdrawnReserves = info.withdrawnReserves;
        require(amount <= totalReserves - withdrawnReserves, Errors.WITHDRAW_AMOUNT_EXCEED);
        info.withdrawnReserves = info.withdrawnReserves + amount;
        IERC20(token).safeTransfer(_MAINTAINER_, amount);
    }
```
When the owner withdraws reserve, `totalReserves` remain unchanged, `withdrawnReserves` increases, `cash` and `totalBorrows` remain unchanged, resulting in `exchangeRate` instantaneous increase. Let me give you a numerical example:
```shell
1. userDeposit 100     | cash 100 tokenSupply 100 totalBorrows 0  | totalReserves 0 withdrawnReserves 0 | exchangeRate 1
2. poolBorrow 50       | cash 50  tokenSupply 100 totalBorrows 50 | totalReserves 0 withdrawnReserves 0 | exchangeRate 1
3. poolRepay 60        | cash 110 tokenSupply 100 totalBorrows 0  | totalReserves 6 withdrawnReserves 0 | exchangeRate 1.04
4. withdrawnReserves 6 | cash 110 tokenSupply 100 totalBorrows 0  | totalReserves 6 withdrawnReserves 6 | exchangeRate 1.1
```
ExchangeRate change in step3 is normal, because it is the interest that accrues by staking over a certain amount of time, a malicious user will not be able to take advantage of this change in exchangeRate unless he has previously deposited a certain amount of tokens and keep staking. Because as soon as the user deposits, exchangeRate is updated to the latest state.  
However, for step4, exchangeRate is the instantaneous change generated by `withdrawnReserves` action, and an arbitrage opportunity is generated.    
The searcher can monitor the mempool and monitor the `withdrawReserves` action for sandwich arbitrage: `userDeposit -> withdrawReserves -> userWithdraw` to steal interest that should have gone to staking users. It can even steal the user's fund and drain the vault if the capital volume is large, of course the protocol has a quota limit that may mitigate the losses.  

## Impact

`withdrawnReserves` action leads to the instantaneous increase of `exchangeRate`, which creates an arbitrage opportunity. Malicious users can steal fund through the sandwich, resulting in the fund loss of the staking users.    

## Code Snippet

- https://github.com/sherlock-audit/2023-06-dodo/blob/a8d30e611acc9762029f8756d6a5b81825faf348/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol#L339

## Tool used

Manual Review

## Recommendation

ExchangeRate should not be able to change instantaneously, only the staking can rise slowly
```diff
diff --git a/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol b/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol
index 2fb9364..e31fb8b 100644
--- a/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol
+++ b/new-dodo-v3/contracts/DODOV3MM/D3Vault/D3VaultFunding.sol
@@ -162,6 +162,7 @@ contract D3VaultFunding is D3VaultStorage {
         accrualTime = currentTime;
     }
 
+
     /// @notice Accrue interest for a token, change storage
     function accrueInterest(address token) public {
         (assetInfo[token].totalBorrows, assetInfo[token].totalReserves, assetInfo[token].borrowIndex, assetInfo[token].accrualTime) =
@@ -232,7 +233,7 @@ contract D3VaultFunding is D3VaultStorage {
         uint256 cash = getCash(token);
         uint256 dTokenSupply = IERC20(info.dToken).totalSupply();
         if (dTokenSupply == 0) { return 1e18; }
-        return (cash + info.totalBorrows - (info.totalReserves - info.withdrawnReserves)).div(dTokenSupply);
+        return (cash + info.totalBorrows - info.totalReserves).div(dTokenSupply);
     } 
 
     /// @notice Make sure accrueInterests or accrueInterest(token) is called before

```